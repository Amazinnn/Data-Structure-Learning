/*
# P1115 最大子段和

## 题目描述
给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。

## 输入格式
第一行是一个整数，表示序列的长度 $n$。
第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。

## 输出格式
输出一行一个整数表示答案。


- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

*/
#include <stdio.h>  // 引入标准输入输出库

int main(void)
{
	int n;
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&a[i]);
	
    // 初始化max和sum为序列的第一个元素
    // max: 记录遍历过程中遇到的最大子序列和
    // sum: 记录以当前元素结尾的子序列的和
	long int max=a[0],sum=a[0];
    
    // 从第二个元素开始遍历数组（因为第一个元素已在初始化时处理）
	for (int i=1;i<n;i++){
        // 判断当前子序列和sum是否非负
		if (sum>=0) 
            sum+=a[i];  // 若sum非负，则将当前元素a[i]加入子序列（因为sum可能对后续和有贡献）
		else 
            sum=a[i];  // 若sum为负，则从当前元素a[i]重新开始计算子序列（因为负的sum会拉低后续和）

        // 比较当前子序列和sum与已知最大值max，更新max
		if (sum>max) 
            max=sum;
	}
    
    // 输出整个序列的最大子序列和
	printf("%ld",max);
	return 0;  // 程序正常结束
}

//Kadane算法 


















