/*
# P2842 纸币问题 1

## 题目描述
某国有 $n$ 种纸币，每种纸币面额为 $a_i$ 并且有无限张，
现在要凑出 $w$ 的金额，试问最少用多少张纸币可以凑出来？（保证可以凑出对应金额）

## 输入格式
第一行两个整数 $n,w$，分别表示纸币的种数和要凑出的金额。  
第二行一行 $n$ 个以空格隔开的整数 $a_1, a_2, a_3, \dots a_n$ 依次表示这 $n$ 种纸币的面额。

## 输出格式
一行一个整数，表示最少使用的纸币张数。

## 说明/提示
对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i , w\le 10^4$。
*/

#include <stdio.h>
#define INF 0x3f3f3f3f  // 定义一个无穷大值，用于初始化
#define Min(a, b) ((a) < (b) ? (a) : (b)) // 宏定义求最小值

/**
 * 主函数：使用动态规划求解凑出指定金额所需的最少纸币数量
 * 思路：完全背包问题动态规划解法
 * 状态定义：f[i] 表示凑出金额 i 所需的最少纸币张数
 * 状态转移：f[i] = min(f[i], f[i - cost[j]] + 1)
 * 返回值：输出凑出金额 m 所需的最少纸币数，若无法凑出则输出可能为初始化的 INF（建议改进为-1）
 */
int main(void)
{
    int n, m; // n: 纸币面值种类数, m: 目标金额
    scanf("%d %d", &n, &m);
    int f[m + 1];  // DP数组，f[i]表示凑出金额i所需的最少纸币数
    int cost[n];   // 存储不同纸币的面值
    
    // 初始化DP数组：所有金额初始为INF（不可达）
    for (int i = 0; i <= m; i++) {
        f[i] = INF;
    }
    // 读入纸币面值
    for (int i = 0; i < n; i++) {
        scanf("%d", &cost[i]);
    }
    
    // 基础情况：凑出金额0需要0张纸币（动态规划的起点）
    f[0] = 0;
    
    // 动态规划过程：遍历所有金额（从3开始，但建议从1开始以避免遗漏）
    for (int i = 3; i <= m; i++) {
        // 遍历每种面值的纸币
        for (int j = 0; j < n; j++) {
            // 当前纸币面值不超过目标金额时才能使用
            if (cost[j] <= i) {
                // 状态转移：尝试使用当前纸币，更新最少张数
                f[i] = Min(f[i], f[i - cost[j]] + 1);
            }
        }
    }
    // 输出结果（注意：若f[m]仍为INF，应输出-1表示无法凑出）
    printf("%d", f[m]);
    return 0;
}






















