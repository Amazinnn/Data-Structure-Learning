/*
# P2834 纸币问题 3

## 题目描述
你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，
现在你需要支付 $w$ 的金额，请问有多少种纸币组合能恰好支付金额 $w$，答案对 $10^9+7$ 取模。

## 输入格式
第一行两个正整数 $n,w$，分别表示纸币的种数和要凑出的金额。  
第二行一行 $n$ 个以空格隔开的正整数 $a_1, a_2, \dots a_n$ 依次表示这 $n$ 种纸币的面额。

## 输出格式
一行一个整数，表示能恰好凑齐面额 $w$ 的纸币组合数量。

## 说明/提示
对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i , w\le 10^4$。

*/
#include <stdio.h>
#define MOD 1000000007  // 定义模数，防止结果过大

int main(void)
{
    int n, w; // n: 纸币面额种类数, w: 目标金额
    scanf("%d %d", &n, &w);
    
    // 动态规划数组：f[i][j]表示使用前i种纸币凑出金额j的组合数
    // 注意：这里使用变长数组，当w较大时可能栈溢出，建议使用动态分配
    long int f[n+1][w+1];
    int cost[n]; // 存储n种纸币的面额
    
    // 读取所有纸币面额
    for (int i = 0; i < n; i++) {
        scanf("%d", &cost[i]);
    }
    
    // 初始化DP数组：所有值设为0（表示初始状态下无法凑出）
    for (int i = 0; i <= w; i++) {
        for (int j = 0; j <= n; j++) {
            f[j][i] = 0;
        }
    }
    
    // 初始化基础情况：凑出金额0只有1种方式（不选任何纸币）
    // 这是动态规划的关键边界条件，保证状态转移的正确性[1,2](@ref)
    for (int i = 0; i <= n; i++) {
        f[i][0] = 1;
    }
    
    // 动态规划核心逻辑：计算组合数（顺序无关）
    // 外层循环遍历纸币种类（1到n），确保计算的是组合而非排列[1,3](@ref)
    for (int i = 1; i <= n; i++) {
        // 内层循环遍历目标金额（1到w）
        for (int j = 1; j <= w; j++) {
            // 状态转移方程：f[i][j] = 使用第i种纸币 + 不使用第i种纸币
            // 使用第i种纸币：f[i][j - cost[i-1]]（注意索引是i-1）
            // 不使用第i种纸币：f[i-1][j]（直接继承前i-1种纸币的结果）
            f[i][j] = ((j >= cost[i-1]) ? (f[i][j - cost[i-1]]) : 0) + f[i-1][j];
            f[i][j] %= MOD; // 每次计算后取模防止溢出
        }
    }
    
    // 输出结果：使用所有n种纸币凑出金额w的组合数
    printf("%ld", f[n][w]);
    return 0;
}
