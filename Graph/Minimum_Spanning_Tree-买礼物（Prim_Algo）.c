/*
# P1194 买礼物

## 题目描述

又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。
但是，商店老板说最近有促销活动，也就是：
如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。
现在明明想知道，他最少要花多少钱。

## 输入格式

第一行两个整数，$A,B$。
接下来 $B$ 行，每行 $B$ 个数，第 $I$ 行第 $J$ 个为 $K_{I,J}$。
我们保证 $K_{I,J}=K_{J,I}$ 并且 $K_{I,I}=0$。
特别的，如果 $K_{I,J}=0$，那么表示这两样东西之间不会导致优惠。
注意 $K_{I,J}$ **可能大于** $A$。

## 输出格式

一个整数，为最小要花的钱数。
先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。
（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）

数据规模
对于 $30\%$ 的数据，$1\le B\le 10$。
对于 $100\%$ 的数据，$1\le B\le500,0\le A,K_{I,J}\le1000$。
*/
#include <stdio.h>
#define MAX 500

int graph[MAX+1][MAX+1];  // 邻接矩阵存储图，大小为(B+1)×(B+1)
int dis[MAX+1];           // 存储每个顶点到当前最小生成树的最小距离
int visited[MAX+1];       // 标记顶点是否已加入最小生成树

int main(void)
{
	int A,B;
	scanf("%d %d",&A,&B);
	
	// 关键思路：创建虚拟顶点0，代表"直接购买"的起点
	// 顶点0到每个物品i的边权重为A（直接购买价格）
	for (int i=0;i<=B;i++)
		graph[i][0]=graph[0][i]=A;  // 无向图，对称设置
	
	// 读取优惠矩阵，构建物品之间的边
	for (int i=1;i<=B;i++){
		for (int j=1;j<=B;j++){
			int k;
			scanf("%d",&k);
			// 如果k=0表示无优惠，使用原价A；否则使用优惠价k
			graph[i][j]=(k==0)?A:k;
		}
	}
	
	// 初始化：所有物品顶点未访问，初始距离为直接购买价A
	for (int i=1;i<=B;i++){
		visited[i]=0;
		dis[i]=A;
	}
	dis[0]=0;        // 虚拟顶点0到自己的距离为0
	visited[0]=1;    // 虚拟顶点0默认已加入生成树
	
	long int total=0;  // 总花费
	
	// Prim算法主循环：每次加入一个顶点，共需加入B个物品顶点
	for (int i=1;i<=B;i++){
		int mini=1;    // 寻找当前距离最小的顶点
		
		// 遍历所有顶点，找到未访问顶点中dis值最小的
		for (int j=1;j<=B;j++){
			if (!visited[j]&&(dis[mini]>dis[j]))
				mini=j;
		}
		
		visited[mini]=1;     // 将顶点mini加入最小生成树
		total+=dis[mini];    // 累加当前最小边的权值
		
		// 更新阶段：检查新加入顶点mini的所有邻接边
		// 如果通过mini到达其他未访问顶点的距离更小，则更新dis数组
		for (int s=1;s<=B;s++){
			if (!visited[s]&&graph[s][mini]<dis[s])
				dis[s]=graph[s][mini];  // 更新到生成树的最小距离
		}
	}
	
	printf("%ld",total);
	return 0;
}


















