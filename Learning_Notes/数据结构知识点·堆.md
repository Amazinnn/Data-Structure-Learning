### 二叉堆 ###

#### 一、堆的基本概念 ####

​	**二叉堆**是一种基于完全二叉树的数据结构，分为大根堆和小根堆两种形式。它们共享相同的结构特性，但在元素大小关系上正好相反。

#### 二、完全二叉树结构 ####

1. 只允许最后一行不满；
2. 最后一行节点必须从左到右连续排列。这种结构确保了堆的高效存储和操作。

#### 三、堆序性对比 ####

**大根堆**：每个父节点的值都大于或等于其子节点的值，根节点是最大值。

**小根堆**：每个父节点的值都小于或等于其子节点的值，根节点是最小值。

​	两者的区别仅在于比较方向，基本操作逻辑完全相同。

#### 四、堆的存储方式 ####

​	由于都是完全二叉树，大根堆和小根堆的存储方式完全一致。通过数组按层序遍历存储，索引关系为：

- 父节点索引`i`，左子节点索引`2*i+1`
- 父节点索引`i`，右子节点索引`2*i+2`
- 子节点索引`i`，父节点索引`(i-1)/2`（整数除法）

```c
// 堆结构定义（同时适用于大根堆和小根堆）
typedef struct {
    int *arr;       // 存储堆元素的数组
    int size;       // 当前堆大小
    int capacity;   // 堆容量
} BinaryHeap;
```

#### 五、基本操作：上滤与下滤 ####

上滤和下滤是维护堆序性的核心操作。大根堆和小根堆的这两种操作逻辑流程相同，但比较方向相反。

**上滤操作对比**：

- 大根堆：当前节点比父节点大时交换
- 小根堆：当前节点比父节点小时交换

```c
// 大根堆上滤
void heapifyUpMax(BinaryHeap* heap, int index) {
    while (index > 0) {
        int parent = (index - 1) / 2;
        // 大根堆：子节点大于父节点时交换
        if (heap->arr[index] <= heap->arr[parent]) {
            break;
        }
        int temp = heap->arr[index];
        heap->arr[index] = heap->arr[parent];
        heap->arr[parent] = temp;
        index = parent;
    }
}

// 小根堆上滤
void heapifyUpMin(BinaryHeap* heap, int index) {
    while (index > 0) {
        int parent = (index - 1) / 2;
        // 小根堆：子节点小于父节点时交换
        if (heap->arr[index] >= heap->arr[parent]) {
            break;
        }
        int temp = heap->arr[index];
        heap->arr[index] = heap->arr[parent];
        heap->arr[parent] = temp;
        index = parent;
    }
}
```

**下滤操作对比**：

- 大根堆：与较大的子节点比较，当前节点小于较大子节点时交换
- 小根堆：与较小的子节点比较，当前节点大于较小子节点时交换

```c
// 大根堆下滤
void heapifyDownMax(BinaryHeap* heap, int index) {
    int largest = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;
    
    if (left < heap->size && heap->arr[left] > heap->arr[largest]) {
        largest = left;  // 大根堆：找较大子节点
    }
    if (right < heap->size && heap->arr[right] > heap->arr[largest]) {
        largest = right;  // 大根堆：找较大子节点
    }
    
    if (largest != index) {
        int temp = heap->arr[index];
        heap->arr[index] = heap->arr[largest];
        heap->arr[largest] = temp;
        heapifyDownMax(heap, largest);
    }
}

// 小根堆下滤
void heapifyDownMin(BinaryHeap* heap, int index) {
    int smallest = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;
    
    if (left < heap->size && heap->arr[left] < heap->arr[smallest]) {
        smallest = left;  // 小根堆：找较小子节点
    }
    if (right < heap->size && heap->arr[right] < heap->arr[smallest]) {
        smallest = right;  // 小根堆：找较小子节点
    }
    
    if (smallest != index) {
        int temp = heap->arr[index];
        heap->arr[index] = heap->arr[smallest];
        heap->arr[smallest] = temp;
        heapifyDownMin(heap, smallest);
    }
}
```

#### 六、插入操作 ####

插入操作在两个堆中都是将新元素放在末尾，然后执行上滤操作。区别仅在于比较方向：

```c
// 大根堆插入
void insertMaxHeap(BinaryHeap* heap, int value) {
    if (heap->size >= heap->capacity) {
        printf("堆已满\n");
        return;
    }
    heap->arr[heap->size] = value;
    heapifyUpMax(heap, heap->size);
    heap->size++;
}

// 小根堆插入
void insertMinHeap(BinaryHeap* heap, int value) {
    if (heap->size >= heap->capacity) {
        printf("堆已满\n");
        return;
    }
    heap->arr[heap->size] = value;
    heapifyUpMin(heap, heap->size);
    heap->size++;
}
```

#### 七、删除堆顶元素 ####

删除堆顶时，都用最后一个元素替换堆顶，然后执行下滤操作：

```c
// 大根堆删除堆顶
int extractMax(BinaryHeap* heap) {
    if (heap->size <= 0) {
        printf("堆为空\n");
        return -1;
    }
    int max = heap->arr[0];  // 大根堆堆顶是最大值
    heap->arr[0] = heap->arr[heap->size - 1];
    heap->size--;
    heapifyDownMax(heap, 0);
    return max;
}

// 小根堆删除堆顶
int extractMin(BinaryHeap* heap) {
    if (heap->size <= 0) {
        printf("堆为空\n");
        return -1;
    }
    int min = heap->arr[0];  // 小根堆堆顶是最小值
    heap->arr[0] = heap->arr[heap->size - 1];
    heap->size--;
    heapifyDownMin(heap, 0);
    return min;
}
```

#### 八、建堆方法对比 ####

两种堆都可以使用相同的建堆方法，区别仅在于使用的下滤函数不同：

```c
// 构建大根堆
void buildMaxHeap(BinaryHeap* heap, int array[], int n) {
    for (int i = 0; i < n; i++) {
        heap->arr[i] = array[i];
    }
    heap->size = n;
    
    // 从最后一个非叶子节点开始
    for (int i = n/2 - 1; i >= 0; i--) {
        heapifyDownMax(heap, i);
    }
}

// 构建小根堆
void buildMinHeap(BinaryHeap* heap, int array[], int n) {
    for (int i = 0; i < n; i++) {
        heap->arr[i] = array[i];
    }
    heap->size = n;
    
    // 从最后一个非叶子节点开始
    for (int i = n/2 - 1; i >= 0; i--) {
        heapifyDownMin(heap, i);
    }
}
```

#### 九、堆排序应用 ####

堆排序的关键区别：

- **大根堆**：适合升序排序。每次取出堆顶（最大值）放在数组末尾
- **小根堆**：适合降序排序。每次取出堆顶（最小值）放在数组末尾

```c
// 使用大根堆进行升序排序
void heapSortAscending(int arr[], int n) {
    // 构建大根堆
    for (int i = n/2 - 1; i >= 0; i--) {
        heapifyDownMaxForSort(arr, n, i);
    }
    
    // 排序
    for (int i = n - 1; i > 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        heapifyDownMaxForSort(arr, i, 0);
    }
}

// 使用小根堆进行降序排序
void heapSortDescending(int arr[], int n) {
    // 构建小根堆
    for (int i = n/2 - 1; i >= 0; i--) {
        heapifyDownMinForSort(arr, n, i);
    }
    
    // 排序
    for (int i = n - 1; i > 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        heapifyDownMinForSort(arr, i, 0);
    }
}
```

#### 十、优先队列实现 ####

优先队列是堆的主要应用，可以使用大根堆或小根堆实现，取决于优先级定义：

- 大根堆优先队列：优先级高的元素在堆顶
- 小根堆优先队列：优先级低的元素在堆顶

```
// 优先队列通用操作
typedef struct {
    BinaryHeap heap;
    int isMaxHeap;  // 1表示大根堆，0表示小根堆
} PriorityQueue;

// 入队操作
void enqueue(PriorityQueue* pq, int value) {
    if (pq->isMaxHeap) {
        insertMaxHeap(&pq->heap, value);
    } else {
        insertMinHeap(&pq->heap, value);
    }
}

// 出队操作
int dequeue(PriorityQueue* pq) {
    if (pq->isMaxHeap) {
        return extractMax(&pq->heap);
    } else {
        return extractMin(&pq->heap);
    }
}
```

#### 十一、总结 ####

大根堆和小根堆是同一数据结构的两种变体，它们的**相同点**包括：

1. 都是完全二叉树结构
2. 存储方式和索引关系相同
3. 基本操作（上滤、下滤）流程相同
4. 建堆方法相同
5. 时间复杂度相同（插入O(log n)，删除O(log n)，建堆O(n)）

它们的**主要区别**在于：

1. 比较方向相反
2. 堆顶元素属性不同（最大值vs最小值）
3. 在堆排序中的应用场景不同（升序vs降序）
4. 在优先队列中表示的优先级方向不同

​	在实际应用中，应根据具体需求选择合适的堆类型。如果需要频繁获取最大值，使用大根堆；如果需要频繁获取最小值，使用小根堆。



### 二叉堆：上滤与下滤 ###

#### 一、基本定义与功能对比 ####

**1.1 上滤（Percolate Up / Sift Up）**

​	**上滤**是将一个节点**从下往上**调整的操作，通常用于插入新元素时，使其在堆中找到正确位置。从新插入的元素开始，与其父节点比较，如果不满足堆序性则交换，直到满足堆序性或到达根节点。

**1.2 下滤（Percolate Down / Sift Down）**

​	**下滤**是将一个节点**从上往下**调整的操作，通常用于删除根节点或调整堆结构时。从指定的节点（通常是根节点）开始，与其子节点比较，如果不满足堆序性则与合适的子节点交换，直到满足堆序性或到达叶子节点。

```c
// 上滤和下滤的代码框架对比
// 上滤：从下向上比较
void percolateUp(Heap* heap, int index) {
    while (index > 0) {
        int parent = (index - 1) / 2;
        if (满足堆序性条件) break;
        交换(heap->arr[index], heap->arr[parent]);
        index = parent;  // 向上移动
    }
}

// 下滤：从上向下比较
void percolateDown(Heap* heap, int index) {
    while (有子节点) {
        int child = 找到合适的子节点;
        if (满足堆序性条件) break;
        交换(heap->arr[index], heap->arr[child]);
        index = child;  // 向下移动
    }
}
```

#### 二、核心功能对比 ####

| 特性           | 上滤                   | 下滤                     |
| -------------- | ---------------------- | ------------------------ |
| **移动方向**   | 自底向上               | 自顶向下                 |
| **主要用途**   | 插入新元素             | 删除根节点、调整堆结构   |
| **比较对象**   | 与父节点比较           | 与子节点比较             |
| **终止条件**   | 到达根节点或满足堆序性 | 到达叶子节点或满足堆序性 |
| **时间复杂度** | O(log n)               | O(log n)                 |

#### 三、应用场景的异同 ####

**3.1 插入操作：必须使用上滤**

​	当向堆中插入新元素时，新元素**必须**被放置在数组末尾（堆的最后一个位置），然后通过**上滤**操作将其移动到正确位置。

> [!IMPORTANT]
>
> **为什么必须用上滤？**
>
> - 新元素插入的位置是确定的（末尾）
> - 只需要与其父节点比较，向上找到合适位置
> - 下滤无法处理这种情况，因为新元素没有子节点

```c
// 插入操作：必须使用上滤
void heapInsert(Heap* heap, int value) {
    if (heap->size >= heap->capacity) {
        printf("堆已满\n");
        return;
    }
    // 1. 新元素放到末尾
    heap->arr[heap->size] = value;
    
    // 2. 使用上滤调整位置
    int index = heap->size;
    heap->size++;
    
    // 上滤过程
    while (index > 0) {
        int parent = (index - 1) / 2;
        if (heap->arr[index] <= heap->arr[parent]) break;  // 小根堆条件
        // 不满足条件则交换
        int temp = heap->arr[index];
        heap->arr[index] = heap->arr[parent];
        heap->arr[parent] = temp;
        index = parent;
    }
}
```

**3.2 删除根节点操作：必须使用下滤**

​	当从堆中删除根节点时，用最后一个元素替换根节点，然后通过**下滤**操作调整堆结构。

> [!IMPORTANT]
>
> **为什么必须用下滤？**
>
> - 删除后，根位置是一个"新"元素（来自末尾）
> - 这个元素需要向下找到合适位置
> - 上滤无法处理这种情况，因为从根节点开始没有父节点可比较

```c
// 删除堆顶操作：必须使用下滤
int heapExtractTop(Heap* heap) {
    if (heap->size <= 0) {
        printf("堆为空\n");
        return -1;
    }
    
    // 1. 保存根节点值
    int top = heap->arr[0];
    
    // 2. 用最后一个元素替换根节点
    heap->arr[0] = heap->arr[heap->size - 1];
    heap->size--;
    
    // 3. 使用下滤调整堆结构
    int index = 0;
    while (index * 2 + 1 < heap->size) {  // 有左子节点
        int left = index * 2 + 1;
        int right = index * 2 + 2;
        int child = left;
        
        // 小根堆：选择较小的子节点
        if (right < heap->size && heap->arr[right] < heap->arr[left]) {
            child = right;
        }
        
        // 如果已满足堆序性，停止
        if (heap->arr[index] <= heap->arr[child]) break;
        
        // 交换
        int temp = heap->arr[index];
        heap->arr[index] = heap->arr[child];
        heap->arr[child] = temp;
        index = child;
    }
    
    return top;
}
```

**3.3 建堆操作：优先使用下滤**

**Floyd建堆法**（自下而上建堆）中，通常使用**下滤**，因为：

1. 从最后一个非叶子节点开始，这些节点都有子节点
2. 下滤可以一次性将整个子树调整正确
3. 时间复杂度更低：O(n)，而使用上滤的建堆法为O(n log n)

```
// Floyd建堆法：使用下滤
void buildHeapFloyd(int arr[], int n) {
    // 从最后一个非叶子节点开始
    for (int i = n/2 - 1; i >= 0; i--) {
        percolateDown(arr, n, i);  // 使用下滤
    }
}

// 逐个插入建堆法：使用上滤
void buildHeapByInsert(int arr[], int n) {
    for (int i = 1; i < n; i++) {  // 从第2个元素开始
        int index = i;
        // 对新插入的元素使用上滤
        while (index > 0) {
            int parent = (index - 1) / 2;
            if (arr[parent] <= arr[index]) break;  // 大根堆条件
            int temp = arr[index];
            arr[index] = arr[parent];
            arr[parent] = temp;
            index = parent;
        }
    }
}
```

**3.4 修改堆中元素值**

​	当修改堆中某个元素的值时，需要根据值的变化方向选择操作：

- 值**增大**（小根堆）或**减小**（大根堆）：可能需要**下滤**
- 值**减小**（小根堆）或**增大**（大根堆）：可能需要**上滤**

```
// 修改堆中元素值
void heapChangeKey(Heap* heap, int index, int newValue) {
    int oldValue = heap->arr[index];
    heap->arr[index] = newValue;
    
    if (heap->isMinHeap) {  // 小根堆
        if (newValue < oldValue) {
            // 值变小了，可能向上移动
            percolateUp(heap, index);
        } else if (newValue > oldValue) {
            // 值变大了，可能向下移动
            percolateDown(heap, index);
        }
    } else {  // 大根堆
        if (newValue > oldValue) {
            // 值变大了，可能向上移动
            percolateUp(heap, index);
        } else if (newValue < oldValue) {
            // 值变小了，可能向下移动
            percolateDown(heap, index);
        }
    }
}
```

#### 四、为什么不能互换使用？ ####

**4.1 上滤不能替代下滤的情况**

1. **删除根节点时**：上滤没有意义，因为根节点没有父节点
2. **建堆时**：使用上滤的复杂度更高（O(n log n) vs O(n)）

**4.2 下滤不能替代上滤的情况**

1. **插入新元素时**：下滤从末尾开始无法工作，因为末尾元素没有子节点
2. **修改元素值使其更优时**：如果值变得更好（对小根堆是更小，对大根堆是更大），需要向上调整

#### 五、算法复杂度的深入分析 ####

**5.1 上滤的复杂度**

- 最坏情况：元素从叶子节点移动到根节点
- 移动距离：树的高度 h = ⌊log₂n⌋
- 每次比较交换：O(1)
- 总复杂度：O(log n)

**5.2 下滤的复杂度**

- 最坏情况：元素从根节点移动到叶子节点
- 移动距离：树的高度 h = ⌊log₂n⌋
- 每次比较交换：O(1)（但需要比较两个子节点）
- 总复杂度：O(log n)

**5.3 建堆复杂度差异**

```c
// 使用上滤逐个插入建堆：O(n log n)
// 原因：第i个元素最多需要上滤log i次
// 总复杂度：Σ(log i) for i=1 to n ≈ n log n

// 使用下滤Floyd建堆：O(n)
// 原因：大部分节点只需要下滤很少的层数
// 数学证明：对于高度为h的节点，最多下滤h次
// 总复杂度：Σ(h * 2^(H-h)) for h=0 to H，其中H是树的总高度
```

#### 六、实际应用中的选择策略 ####

**6.1 何时使用上滤？**

1. **插入新元素时**：必须使用
2. **减小键值（小根堆）或增大键值（大根堆）时**：值变得"更好"
3. **增量构建堆**：当元素逐个到达时

**6.2 何时使用下滤？**

1. **删除根节点时**：必须使用
2. **批量构建堆**：已有所有数据
3. **增大键值（小根堆）或减小键值（大根堆）时**：值变得"更差"
4. **堆排序的调整阶段**：每次交换后

**6.3 综合示例：堆排序的不同实现**

```c
// 堆排序：使用下滤
void heapSort(int arr[], int n) {
    // 步骤1：构建大根堆（使用下滤）
    for (int i = n/2 - 1; i >= 0; i--) {
        percolateDown(arr, n, i);
    }
    
    // 步骤2：排序
    for (int i = n-1; i > 0; i--) {
        // 交换根节点和最后一个节点
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        
        // 对根节点下滤
        percolateDown(arr, i, 0);
    }
}

// 动态堆排序：使用上滤和下滤
void dynamicHeapSort(int arr[], int n) {
    Heap* heap = createHeap(n);
    
    // 步骤1：插入所有元素（使用上滤）
    for (int i = 0; i < n; i++) {
        heapInsert(heap, arr[i]);  // 内部使用上滤
    }
    
    // 步骤2：提取所有元素（使用下滤）
    for (int i = 0; i < n; i++) {
        arr[i] = heapExtractTop(heap);  // 内部使用下滤
    }
}
```

#### 七、性能优化技巧 ####

**7.1 减少交换操作**

```c
// 优化版上滤：先找到正确位置，再一次性移动
void percolateUpOptimized(Heap* heap, int index, int value) {
    while (index > 0) {
        int parent = (index - 1) / 2;
        if (heap->arr[parent] <= value) break;  // 大根堆条件
        heap->arr[index] = heap->arr[parent];  // 只移动父节点下来
        index = parent;
    }
    heap->arr[index] = value;  // 最后放入正确位置
}

// 优化版下滤
void percolateDownOptimized(Heap* heap, int index, int value) {
    while (index * 2 + 1 < heap->size) {
        int child = index * 2 + 1;
        if (child + 1 < heap->size && heap->arr[child + 1] < heap->arr[child]) {
            child++;  // 选择较小的子节点
        }
        if (value <= heap->arr[child]) break;  // 小根堆条件
        heap->arr[index] = heap->arr[child];  // 只移动子节点上来
        index = child;
    }
    heap->arr[index] = value;  // 最后放入正确位置
}
```

#### 八、总结 ####

| 方面             | 上滤                                            | 下滤                                                      |
| ---------------- | ----------------------------------------------- | --------------------------------------------------------- |
| **主要用途**     | 插入操作，值改善时的调整                        | 删除操作，值恶化时的调整，建堆                            |
| **方向**         | 自底向上                                        | 自顶向下                                                  |
| **时间复杂度**   | O(log n)                                        | O(log n)                                                  |
| **比较对象**     | 父节点                                          | 子节点                                                    |
| **能否互换**     | 不能替代下滤的删除功能                          | 不能替代上滤的插入功能                                    |
| **复杂度证明**   | 容易分析，每次上移一层                          | 稍微复杂，需要考虑子树结构                                |
| **内存访问模式** | 通常访问较近的父节点                            | 通常访问较远的子节点                                      |
| **缓存友好性**   | 较好（访问局部性）                              | 较差（可能访问不连续内存）                                |
| **适用场景**     | 1. 插入新元素 2. 减小键值（小根堆） 3. 增量构建 | 1. 删除根节点 2. 批量建堆 3. 增大键值（小根堆） 4. 堆排序 |

**关键理解**：

1. 上滤和下滤**不是可互换的等效操作**，它们解决不同的问题
2. 上滤适用于**自底向上**的调整，而下滤适用于**自顶向下**的调整
3. 选择哪种操作取决于**数据结构的变化方向和位置**
4. 在实现优先队列等数据结构时，通常**同时需要两种操作**来支持完整的接口

​	上滤和下滤虽然都用于维护堆序性，但它们的应用场景是互补而非重叠的。理解它们各自的适用场景和限制，是正确实现和优化堆相关算法的关键。