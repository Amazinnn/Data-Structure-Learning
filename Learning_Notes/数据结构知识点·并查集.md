###高度、大小与秩

#### ⚙️ 并查集的核心优化策略 ####

​	并查集是处理动态连通性问题的优雅数据结构，其性能很大程度上依赖于优化策略。在基础并查集中，随意合并可能导致树退化成链，使查找操作变慢。优化核心在于**控制树高**。

1. **按大小合并 (Union by Size)**

- **本质**：在每次合并时，将**元素数量较少**的集合的根节点，连接到元素数量较多的集合的根节点下。
- **实现**：需要一个 `size[]`数组记录每个根节点所代表的集合的元素总数（初始为1）。
- **用处**：直观且有效，能避免小树“拉高”大树的深度。合并后，树的高度增长相对缓慢，能保证树高为 `O(log n)`。

2. **按秩合并与“秩”的本质 (Union by Rank)**

- **秩的本质**：`秩`是树高的一个**上界或估计值**，而非精确高度。这是为了与路径压缩优化兼容。路径压缩会改变树的实际高度，但如果我们不更新所有节点的秩（因为这样做代价高昂），秩就保留了原始的高度信息，成为一个“历史记录”或“排名”。
- **本质**：在合并时，将**秩较小**的树的根节点，连接到秩较大的树的根节点下。若两树秩相等，则新根的秩需加1。
- **用处**：从理论上看，按秩合并在控制树高方面通常比按大小合并更精确和严格。它与路径压缩结合后，可达到近乎常数时间的操作复杂度 `O(α(n))`。( 反阿克曼函数 )

下表直观对比了这两种策略的核心差异：

| 特性         | 按大小合并                           | 按秩合并                           |
| ------------ | ------------------------------------ | ---------------------------------- |
| **优化目标** | 控制集合规模，降低高增长概率         | **最小化树的高度**，优化查询路径   |
| **决策依据** | 集合的元素数量                       | 树的秩（高度上界）                 |
| **树高控制** | 相对宽松，树高可能因小集合较高而增加 | **严格控高**，查询效率更稳定       |
| **额外空间** | 可复用父节点数组（存负值大小）       | 通常需要独立的 `rank[]`数组        |
| **适用场景** | 需要动态统计集合大小（如社群分析）   | **高频查询**（如算法竞赛、图算法） |

3. **共同点与协同效应**

- **共同目标**：两者都通过优化合并顺序来**避免树的不平衡增长**，将操作复杂度从 `O(n)`降至 `O(log n)`级别。
- **协同作用**：它们都可以与**路径压缩** 技术完美结合。路径压缩在查找操作中将路径上的节点直接指向根节点，进一步扁平化树结构。结合后，均摊时间复杂度可达 `O(α(n))`，对于所有实际应用场景，这几乎就是常数时间。

#### 💻按秩合并 + 路径压缩 ####

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXN 1000 // 假设最大元素数量

typedef struct {
    int parent[MAXN]; // 父节点数组
    int rank[MAXN];   // 秩数组
    int count;        // 集合数量（可选）
} UnionFind;

// 初始化并查集
void initUnionFind(UnionFind *uf, int n) {
    for (int i = 0; i < n; i++) {
        uf->parent[i] = i; // 每个元素的父节点是自己
        uf->rank[i] = 0;   // 初始秩为0
    }
    uf->count = n; // 初始时每个元素自成一个集合
}

// 查找操作（带路径压缩）
int find(UnionFind *uf, int x) {
    if (uf->parent[x] != x) {
        uf->parent[x] = find(uf, uf->parent[x]); // 路径压缩：将x的父节点直接设置为根节点
    }
    return uf->parent[x];
}

// 合并操作（按秩合并）
void unionSets(UnionFind *uf, int x, int y) {
    int rootX = find(uf, x);
    int rootY = find(uf, y);

    // 如果两个元素已经在同一个集合中，则不需要合并
    if (rootX == rootY) return;

    // 按秩合并：将秩小的树合并到秩大的树下
    if (uf->rank[rootX] < uf->rank[rootY]) {
        uf->parent[rootX] = rootY;
    } else if (uf->rank[rootX] > uf->rank[rootY]) {
        uf->parent[rootY] = rootX;
    } else {
        // 两棵树秩相等，任意合并，但新树的秩需加1
        uf->parent[rootY] = rootX;
        uf->rank[rootX]++;
    }

    uf->count--; // 集合数量减一
}

// 检查两个元素是否连通
int isConnected(UnionFind *uf, int x, int y) {
    return find(uf, x) == find(uf, y);
}

// 获取当前集合的数量
int getSetCount(UnionFind *uf) {
    return uf->count;
}

// 简单测试
int main() {
    UnionFind uf;
    int n = 5; // 假设有5个元素（0到4）

    initUnionFind(&uf, n);

    // 执行一系列合并操作
    unionSets(&uf, 0, 1);
    unionSets(&uf, 2, 3);
    unionSets(&uf, 1, 4);
    unionSets(&uf, 3, 4); // 此时所有元素应连通

    // 测试连通性
    printf("0和4是否连通? %s\n", isConnected(&uf, 0, 4) ? "是" : "否");
    printf("当前集合数量: %d\n", getSetCount(&uf)); // 应输出1

    return 0;
}
```



### 秩的本质

​	**树的实际高度在路径压缩后会减小，但算法中“秩”这个数值并不会被相应减小。** 这不是一个疏忽，而是一种有意的、关键的设计。

| 特性         | 实际高度 (Real Height)                             | 秩 (Rank)                                                   |
| ------------ | -------------------------------------------------- | ----------------------------------------------------------- |
| **定义**     | 从该节点到根节点的**最长路径**上经过的边数。       | 树高的一个**上界估计值**，是一个“历史高度记录”。            |
| **变化**     | **动态变化**。路径压缩会**立即降低**树的实际高度。 | **单调不减**。一旦设定，在合并操作外**不会减少**。          |
| **更新时机** | 每次查找（带路径压缩）后都可能改变。               | ==仅==在**按秩合并**操作中，当两棵树秩相等时，新根的秩加1。 |
| **用途**     | 直接影响单次查找操作的效率。                       | 为合并操作提供决策依据，**保证长期效率**。                  |
| **关系**     | 实际高度 ≤ 秩                                      | 秩 ≥ 实际高度                                               |

💡 **为什么要这样设计**？核心原因是**权衡利弊，追求全局最优效率**。

1. **效率优先，避免更新成本** 路径压缩的目标是加速未来的查找操作。如果每次压缩路径后，都去更新从叶子节点到根节点整条路径上所有节点的“秩”，那么这个“更新秩”的操作本身就会非常耗时，其时间复杂度可能与一次查找操作相当（O(n)级别）。这就完全违背了路径压缩的初衷，使得优化得不偿失。
2. **“秩”的本质是“保证”而非“测量”** “秩”的真正作用不是精确反映当前树的高度，而是为合并操作提供一个**可靠的上界**。只要保证 `秩 >= 实际高度`，按秩合并就能有效工作。在合并时，将秩小的树合并到秩大的树下，可以确保树的高度不会急剧增长。即使秩被高估了，这个决策依然是正确的。
3. **秩的单调性简化了证明和实现** 保持秩只增不减（单调性）使得并查集复杂度的数学证明变得可行。著名的“阿克曼函数的反函数 α(n)”这一近乎常数的复杂度结论，正是基于路径压缩和按秩合并（且秩不递减）这一组合得出的。如果秩会减少，复杂度分析将变得极其复杂。

🔄 **秩是如何维持其上界角色的**？关键在于合并操作的逻辑：

- 当两棵树的秩不相等时（假设rank[A] = 3, rank[B] = 2），将B树合并到A树下。合并后新树的秩保持不变（仍为3）。因为即使B树的实际高度可能由于之前的路径压缩小于2，但合并到更高的A树下，新树的高度就是A树的高度（3），所以秩=3这个估计仍然是有效的上界。
- 当两棵树的秩相等时（假设rank[A] = rank[B] = 2），合并后新根的秩会加1（变为3）。这是一种“保守估计”：因为合并后新树的实际高度最大可能为3（当两棵树高度恰好都是2时），所以将秩设置为3，提前为可能的高度增长留出空间。

> [!IMPORTANT]
>
> ​	“秩”在路径压缩后不减少，是因为**它的角色从一个精确的“高度测量员”转变成了一个“高度保险丝”**。它宁可稍微高估，也绝不低估，以此来**用最小的维护成本（只在合并时调整），为合并操作提供关键决策信息，从而在宏观上保证并查集长期的高效运行**。这种“信息滞后但保证正确”的设计，是并查集算法优雅而强大的关键所在。

