###常见算法的复杂度分析

| 排序算法     | 平均时间复杂度    | 最坏时间复杂度 | 空间复杂度 | 稳定性 | 复杂度简要理由                                               |
| ------------ | ----------------- | -------------- | ---------- | ------ | ------------------------------------------------------------ |
| **冒泡排序** | O(n²)             | O(n²)          | O(1)       | 稳定   | 需要双重循环遍历比较和交换相邻元素。                         |
| **选择排序** | O(n²)             | O(n²)          | O(1)       | 不稳定 | 双重循环遍历查找最小（大）值并进行交换。                     |
| **插入排序** | O(n²)             | O(n²)          | O(1)       | 稳定   | 将未排序元素逐个插入前方已排序序列，最优情况（近乎有序）可接近O(n)。 |
| **希尔排序** | O(n^1.3) 至 O(n²) | O(n²)          | O(1)       | 不稳定 | 是插入排序的改进，通过分组插入排序使元素大步移动，效率取决于增量序列。 |
| **快速排序** | O(n log n)        | O(n²)          | O(log n)   | 不稳定 | 采用分治策略，平均情况下递归深度为log n，每层划分操作耗时O(n)。最坏情况（如有序数组）退化为O(n²)。 |
| **归并排序** | O(n log n)        | O(n log n)     | O(n)       | 稳定   | 采用分治策略，递归地将数组对半分割再合并有序子序列，需要额外临时数组。 |
| **堆排序**   | O(n log n)        | O(n log n)     | O(1)       | 不稳定 | 将数组视为完全二叉树构建堆，通过反复调整堆来排序，初始化堆耗时O(n)。 |
| **计数排序** | O(n + k)          | O(n + k)       | O(n + k)   | 稳定   | 非比较排序，利用数组下标直接定位，其中k是数据的范围。        |
| **桶排序**   | O(n + k)          | O(n²)          | O(n + k)   | 稳定   | 将数据分到有限数量的桶里，每个桶单独排序（通常使用插入排序），效率取决于数据分布和桶数量k。 |
| **基数排序** | O(n * k)          | O(n * k)       | O(n + k)   | 稳定   | 按位排序，从最低位到最高位依次使用稳定排序算法（如计数排序），k是关键字的位数（例如数字的最大位数）。 |





###插入排序 (Insertion Sort) & 希尔排序 (Shell Sort) 

**⏱️ 时间效率 (Time Efficiency)**

- **插入排序**：其核心操作是将未排序区的元素逐个插入到已排序区的正确位置。 **最好情况** `O(n)`：当输入数组已经有序时，每次插入只需比较一次。 **最坏情况** `O(n²)`：当输入数组完全逆序时，每次插入都需要移动已排序区的所有元素。 **平均情况** `O(n²)`。
- **希尔排序**：作为插入排序的改进，它通过分组插入排序（预排序）来提升效率。性能**高度依赖于增量序列（gap sequence）** 的选择。 **时间复杂度**：使用常见增量序列（如`n/2, n/4, ..., 1`）时，平均时间复杂度约为 **O(n^1.3) 至 O(n²)**。最坏情况可达O(n²)，但优于原始插入排序。使用优化序列（如Sedgewick序列）可进一步提升。 效率提升原理：初期增量（gap）较大时，元素能大步移动，快速接近最终位置。后期增量减小时，序列已接近有序，插入排序此时效率很高。

**💾 空间效率 (Space Efficiency)**

- 两种算法都是**原地排序（In-place Sort）**，除了固定的临时变量（如用于元素暂存的`tmp`），不需要额外的存储空间。
- **空间复杂度均为 O(1)**。

**⚖️ 稳定性 (Stability)**

- **插入排序是稳定的 (Stable)**。在插入过程中，只有当新元素小于已排序元素时才发生移动，因此相等的元素可以保持原有的相对顺序。
- **希尔排序是不稳定的 (Unstable)**。由于分组插入，相等的元素可能会被分到不同的组中，并在各自的组内插入过程中打乱原始相对顺序。

**🛠️ 实现难度 (Implementation Complexity)**

- **插入排序**：实现非常简单直观，通常仅需一个双重循环。是初学者学习排序算法的理想起点。 

```c
void insertionSort(int arr[], int n) 
{    
    for (int i = 1; i < n; i++) { // 从第二个元素开始        
        int key = arr[i]; // 待插入的元素        
        int j = i - 1;        // 将大于key的元素后移        
        while (j >= 0 && arr[j] > key) {            
            arr[j + 1] = arr[j];            
            j--;        
        }        
        arr[j + 1] = key; // 插入到正确位置    
    } 
}
```

- **希尔排序**：实现上可看作是插入排序的**泛化版本**。在插入排序的基础上，增加了**控制增量（gap）的循环**，并将内部元素比较和移动的步长从1改为`gap`。理解其分组的预排序过程是关键，难度略高于直接插入排序。 
```c
void shellSort(int arr[], int n) 
{    
	for (int gap = n / 2; gap > 0; gap /= 2) { // 增量序列变化        
        for (int i = gap; i < n; i++) { // 从第gap个元素开始            
            int temp = arr[i];            
            int j;            // 组内执行插入排序，步长为gap            
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {                				arr[j] = arr[j - gap];            
            }            
            arr[j] = temp;        
        }    
    } 
}
```





###快速排序（Quick Sort） & 归并排序（Merge Sort）

**⏱️ 时间效率 (Time Efficiency)**

快速排序和归并排序的平均时间复杂度均为 **O(n log n)**，但它们的性能表现和稳定性存在差异。

- **快速排序 (Quick Sort)**：其性能高度依赖于基准值（pivot）的选择。 **最好/平均情况**：如果每次划分都能将序列大致均分，递归深度为 **log n**，每层划分耗时 **O(n)**，因此平均时间复杂度为 **O(n log n)**。在实践中，由于其良好的缓存局部性（对连续内存的访问），常数因子通常较小，速度较快。 **最坏情况**：当输入序列已有序或逆序，且基准值选择不当（如总是选择第一个或最后一个元素），会导致每次划分极度不平衡（一个子序列为空，另一个包含n-1个元素），递归深度退化为 **n**，时间复杂度变为 **O(n²)**。 **优化策略**：采用“三数取中法”或随机选择基准值，可以有效避免最坏情况的发生。
- **归并排序 (Merge Sort)**：其性能非常稳定，不受输入数据分布的影响。 无论数据初始状态如何，它都会先递归地将序列分割到最小单位（通常为1个元素），然后再自底向上地进行合并。递归深度恒为 **log n**，每次合并操作都需要遍历所有元素，耗时 **O(n)**，因此**最好、最坏、平均时间复杂度均为 O(n log n)**。

**💾 空间效率 (Space Efficiency)**

这是两者差异最显著的地方，归并排序需要较多的额外空间。

- **快速排序**：是一种**原地排序（In-place Sort）** 算法。其主要空间消耗来自于递归调用栈。在最优情况下，递归深度为 **O(log n)**，因此空间复杂度为 **O(log n)**。在最坏情况下，递归深度为 **O(n)**，但通过尾递归优化可以将其降为 **O(log n)**。
- **归并排序**：**不是原地排序**。在合并两个有序子序列时，需要借助一个与原始数组等大的临时数组，因此其**空间复杂度为 O(n)**。这对于内存受限的环境可能是个问题。

**⚖️ 稳定性 (Stability)**

​	稳定性是指相等元素的相对顺序在排序后是否保持不变。

- **快速排序**：**是不稳定的**。在分区过程中，元素会根据与基准值的比较结果进行交换，这可能导致相等元素的相对位置发生变化。 
```c
// 例如，在分区时，一个与基准值相等的元素可能从左边被交换到右边 
int partition(int arr[], int low, int high) 
{    
    int pivot = arr[high]; // 选择最后一个元素为基准    
    int i = (low - 1);    
    for (int j = low; j <= high - 1; j++) {        
        if (arr[j] <= pivot) { // 注意这里是 <=            
            i++;            
            swap(&arr[i], &arr[j]); // 可能交换相等的元素        
        }
    }
    swap(&arr[i + 1], &arr[high]);    
    return (i + 1); 
}
```
- **归并排序**：**是稳定的**。关键在于合并（Merge）步骤。当两个子序列的元素相等时，我们总是优先取前一个子序列（或左子序列）中的元素，从而保证其稳定性。
```c
void merge(int arr[], int l, int m, int r) 
{    // ... 创建临时数组 ...    
    while (i <= m && j <= r) {        
        if (L[i] <= R[j]) { // 注意这里是 <=，优先取左边元素            
            arr[k++] = L[i++];        
        } 
        else {            
            arr[k++] = R[j++];        
        }    
    }    
    // ... 拷贝剩余元素 ... 
}
```

**🛠️ 实现难度 (Implementation Complexity)**

- **快速排序**：核心逻辑（分区函数）相对直观，但**边界条件容易出错**，例如循环的终止条件、基准值的选择和交换逻辑等。一个细微的错误就可能导致无限递归或错误排序。 
```c
// 一个经典的双指针分区实现（Hoare分区法） 
int partition(int arr[], int low, int high) 
{    
    int pivot = arr[(low + high) / 2]; // 三数取中优化    
    int i = low - 1, j = high + 1;    
    while (1) {        
        do { i++; } while (arr[i] < pivot);        
        do { j--; } while (arr[j] > pivot);        
        if (i >= j) return j;        
        swap(&arr[i], &arr[j]);    
    } 
} 

void quickSort(int arr[], int low, int high) 
{    
    if (low < high) 
    {        
        int pi = partition(arr, low, high);        
        quickSort(arr, low, pi);   // 注意递归区间，根据分区法不同可能为 [low, pi-1]
        quickSort(arr, pi + 1, high);    
    } 
}
```
- **归并排序**：算法思路非常清晰，**“分治”思想体现得淋漓尽致**。实现上主要分为“分”和“治”两个步骤，虽然需要额外的空间，但逻辑通常比快速排序更直接，不易出错。 
```c
void mergeSort(int arr[], int l, int r)
{    
    if (l < r) {        
        int m = l + (r - l) / 2; // 找到中间点        
        mergeSort(arr, l, m);     // 递归排序左半部分        
        mergeSort(arr, m + 1, r); // 递归排序右半部分        
        merge(arr, l, m, r);      // 合并两个有序部分    
    } 
} // merge函数实现见上文稳定性部分
```





### 决策树

​	求解基于比较的排序算法时间下界的**决策树模型** (Decision Tree Model) 是理解排序算法极限效率的关键工具。

🌳 **决策树模型核心概念**

决策树是一种**二叉树** (Binary Tree)，它抽象地描述了任何基于比较的排序算法的工作过程。

- **内部节点** (Internal Node)：代表一次**比较操作**，例如 `a_i ≤ a_j?`。这对应算法中一次关键的决策点。
- **分支** (Branches)：代表比较的两种可能结果（“是”或“否”），算法根据结果走向不同的后续操作。
- **叶子节点** (Leaf Node)：代表算法处理完所有比较后，确定的**一种最终排序结果**（即输入序列的一个排列）。

对于 `n`个元素，其所有可能的排列方式有 `n!`种。因此，任何能正确排序的算法，其对应的决策树必须包含至少 `n!`个叶子节点，以涵盖所有可能的有序结果。

### 📏 下界推导 ###

决策树模型的核心结论是：**任何基于比较的排序算法，在最坏情况下的比较次数下界为 Ω(n log n)**。

推导过程基于二叉树的基本性质：

1. **叶子节点数量的下界**：一棵能正确排序 `n`个元素的决策树，其叶子节点数 `L`必须至少为 `n!`，即 `L ≥ n!`。
2. **二叉树高度的下界**：一棵高度为 `h`的二叉树，其最多能拥有的叶子节点数为 `2^h`（满二叉树的情况）。因此，对于有 `L`个叶子节点的决策树，其高度 `h`满足 `2^h ≥ L`。
3. **建立不等式**：结合以上两点，有 `2^h ≥ n!`。
4. **求解高度 `h`**：对不等式两边取以2为底的对数，得到 `h ≥ log₂(n!)`。
5. **近似 `log₂(n!)`**：利用斯特林公式等数学工具，可以证明 `log₂(n!)`的渐进下界为 `Ω(n log n)`（具体推导中，`log₂(n!)`可近似为 `n log₂ n - n log₂ e + ...`，主导项为 `n log n`）。因此，`h = Ω(n log n)`。

这意味着，在最坏情况下，任何基于比较的排序算法都需要至少 `Ω(n log n)`次比较。

### 💡 重要意义 ###

这个下界解释了为什么像**归并排序** (Merge Sort) 和**堆排序** (Heap Sort) 这样的算法被认为是**渐近最优** (Asymptotically Optimal) 的比较排序算法，因为它们的平均和最坏情况时间复杂度都是 `O(n log n)`，与理论下界一致。

决策树模型清晰地揭示了**比较操作**在排序中的根本限制。要突破 `Ω(n log n)`的下界，就必须使用**非比较排序** (Non-comparison Sort) 算法（如计数排序、基数排序等），这些算法利用了输入数据的特定属性，而非仅仅依赖比较。

